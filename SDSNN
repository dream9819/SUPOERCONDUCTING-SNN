# -*- coding: utf-8 -*-
"""
Created on Mon Nov 22 19:00 2021

@author: Lin Ranxi & Dai Benzhe
"""
import numpy as np
import librosa.display
import librosa as lib
import matplotlib.pyplot as plt
import torch
import math

data, sample_rate = librosa.load('test.wav')
print("é•¿åº¦ = {0} ç§’".format(len(data) / sample_rate))

# Sigma-Delta ADC æ—¶åŸŸç¼–ç ï¼ŒNä¸ºç¼–ç é•¿åº¦ï¼ŒVtä¸ºç¼–ç é˜ˆå€¼
# aä¸ºç»è¿‡å‡åŒ€æ± åŒ–æˆ–æœ€å¤§å€¼æ± åŒ–çš„ä¸€ç»´å‘é‡,å…¶ä¸­çš„æ•°å€¼è¢«å˜æ¢åˆ°-1è‡³1çš„èŒƒå›´å†…
def sigma_delta(N, Vt, a, pooling):
    d = np.zeros((a.shape[0], 1))
    feedback = -1
    integrator = 0
    q = len([x for x in list(a) if x > 0])  #
    e = len([x for x in list(a) if x < 0])  #

    # ä½¿ç”¨æ± åŒ–
    if pooling == 1:
        for t in range(a.shape[0]):
            i = 0
            for k in range(N):
                aq = a[t] - feedback + integrator  #
                # é‡åŒ–ç¼–ç 
                if aq > Vt:
                    aq_q = 1
                    i += 1
                else:
                    aq_q = 0
                if aq_q == 1:
                    # aqq = np.sum(np.maximum(a, 0)) / q  # è¯­éŸ³ä¿¡å·æ­£å€¼å¹³å‡å€¼
                    # aqq = a[np.argmax(a)]#å–è¾“å…¥æœ€å¤§å€¼ä¸ºé‡åŒ–è§£ç å€¼
                    aqq = 1
                else:
                    # aqq = np.sum(np.minimum(a, 0)) / e  # è¯­éŸ³ä¿¡å·è´Ÿå€¼å¹³å‡å€¼
                    # aqq = -a[np.argmax(a)]
                    aqq = -1
                feedback = aqq
                integrator = aq
            d[t] = i
    # æ²¡æœ‰ä½¿ç”¨æ± åŒ–
    elif pooling == 0:
        for t in range(a.shape[0]):
            i = 0
            for s in a[0][t]:
                for j in range(3):
                    aq = s - feedback + integrator  #
                    # é‡åŒ–ç¼–ç 
                    if aq > Vt:
                        aq_q = 1
                        i += 1
                    else:
                        aq_q = 0
                    if aq_q == 1:
                        # aqq = np.sum(np.maximum(a, 0)) / q  # è¯­éŸ³ä¿¡å·æ­£å€¼å¹³å‡å€¼
                        # aqq = a[np.argmax(a)]#å–è¾“å…¥æœ€å¤§å€¼ä¸ºé‡åŒ–è§£ç å€¼
                        aqq = 1
                    else:
                        # aqq = np.sum(np.minimum(a, 0)) / e  # è¯­éŸ³ä¿¡å·è´Ÿå€¼å¹³å‡å€¼
                        # aqq = -a[np.argmax(a)]
                        aqq = -1
                    feedback = aqq
                    integrator = aq
                d[t] = i
        # è¾“å‡ºçš„dä¸ºè¾“å…¥å±‚ç¥žç»å…ƒçš„è¾“å…¥ï¼Œæ¯ä¸ªç¥žç»å…ƒæŽ¥æ”¶åˆ°çš„ä¸ºç¼–ç ä¸º1çš„æ•°ç›®çš„æ€»æ•°ã€‚
    return d



# print((np.sum(np.maximum(a,0)) + np.sum(np.minimum(a,0))) / sample_rate) # è¾“å…¥æ•°æ®å¹³å‡å€¼
# E = SDM_time_Domain(1,0.3)
# np.savetxt('E[0].txt',E[0], delimiter=',')
# plt.plot(range(len(E[0])), E[0], 'g')
# plt.show()
class Feature_Extraction:
    def __init__(self, fmin, n_bins, bins_per_octave):
        self.n_bins = n_bins
        self.fmin = fmin
        self.bins = bins_per_octave

    # å¸¸æ•°Qå˜æ¢,librosa.cqtå‡½æ•°ä¸­çš„Qè®¡ç®—å…¬å¼ä¸ºï¼šQ = float(filter_scale) / (2 ** (bins_per_octave) - 1)ï¼Œå¯åœ¨librosa.cqt_frequenciesä»£ç ä¸­æ‰¾åˆ°
    # hop_length=512å¯ä»¥ç†è§£ä¸ºé—´éš”512ä¸ªé‡‡æ ·ç‚¹é‡‡ä¸€ä¸ªå€¼ï¼Œ
    def cqt(self, y, sample_rate):
        return lib.cqt(y, sr=sample_rate, hop_length=512, n_bins=self.n_bins, fmin=self.fmin,
                       bins_per_octave=self.bins)

    # å„é¢‘å¸¦ä¸­å¿ƒé¢‘çŽ‡
    def cqt_F(self):
        return lib.cqt_frequencies(n_bins=self.n_bins, fmin=self.fmin, bins_per_octave=self.bins, tuning=0.0)

    # å„éšé¢‘çŽ‡å˜æ¢çš„çª—å£é•¿åº¦
    def cqt_F_width(self, sample_rate):
        return lib.filters.constant_q_lengths(sample_rate, fmin=self.fmin, n_bins=self.n_bins,
                                              bins_per_octave=self.bins, window='hann', filter_scale=1, gamma=0)


class Spiking_Neural_Network:
    def __init__(self, input_num1, theta_t, theta_b0, input_num2, input_num0, time_window):
        self.input_num0 = input_num0  # è¾“å…¥å±‚ç¥žç»å…ƒæ•°ç›®
        self.input_num1 = input_num1  # éšè—å±‚ç¥žç»å…ƒæ•°ç›®
        self.input_num2 = input_num2  # è¾“å‡ºå±‚ç¥žç»å…ƒæ•°ç›®ï¼Œå¯¹äºŽåˆ†ç±»ä»»åŠ¡ï¼Œæ•°ç›®ä¸º10
        self.list = np.array([self.input_num0, self.input_num1, self.input_num2])
        self.theta = theta_t  # ç¥žç»å…ƒé˜ˆå€¼
        self.theta_b0 = theta_b0  # åˆå§‹ç¥žç»å…ƒåç½®
        self.time_window = time_window  # ç¥žç»å…ƒè¾“å‡ºæ—¶é—´çª—å£
        # self.fai0 = 2.068 * 10 ** (-15)  # å•ç£é€šé‡å­å€¼ä¸º2.068ð‘šð‘£ Ã—ð‘ð‘ 
        self.fai0 = 1 # ç”±äºŽè®¡ç®—è¿‡ç¨‹ä¸­æ‰€æœ‰çš„è¾“å…¥è¾“å‡ºéƒ½æ˜¯ç£é€šé‡å­çš„å€æ•°ï¼Œå› æ­¤å°†å…¶è®¾ç½®ä¸º1æ–¹ä¾¿è®¡ç®—ä»¥åŠé¿å…å•ä½æ¢ç®—
        self.w0 = 1  # Sigma-delta ADCä¸Žç¬¬ä¸€å±‚ç¥žç»å…ƒä¹‹é—´çš„è¿žæŽ¥ä¸è®¾ç½®æƒé‡
        self.w01 = np.random.randn(self.input_num0, self.input_num1)  # åˆå§‹åŒ–è¾“å…¥å±‚ä¸Žéšè—å±‚ä¹‹é—´æƒé‡
        self.w12 = np.random.randn(self.input_num1, self.input_num2)  # åˆå§‹åŒ–éšè—å±‚ä¸Žè¾“å‡ºå±‚ä¹‹é—´æƒé‡
        n0 = np.zeros((self.input_num0, 1)) # è¾“å…¥å±‚çš„è¾“å‡ºè„‰å†²æ•°ç›®
        n1 = np.zeros((self.input_num1, 1)) # éšè—å±‚çš„è¾“å‡ºè„‰å†²æ•°ç›®
        n2 = np.zeros((self.input_num2, 1)) # è¾“å‡ºå±‚çš„è¾“å‡ºè„‰å†²æ•°ç›®
        self.n = np.array(n0, n1, n2) # æœ¬è„‰å†²ç¥žç»ç½‘ç»œçš„è„‰å†²è¾“å‡ºæ•°ç›®æƒ…å†µ
        o0, o1, o2 = np.zeros((self.input_num0, 1)), np.zeros((self.input_num1, 1)), np.zeros((self.input_num2, 1))
        self.o = np.array(o0, o1, o2) # æœ¬ç¥žç»ç½‘ç»œçš„è„‰å†²å‘æ”¾é¢‘çŽ‡çŸ©é˜µ
        self.x = self.theta / self.fai0  # é˜ˆå€¼ä¸Žç£é€šé‡å­çš„æ¯”å€¼a
        theta_b0 = np.zeros(self.input_num0, 1) + self.theta_b0
        theta_b1 = np.zeros(self.input_num1, 1) + self.theta_b0
        theta_b2 = np.zeros(self.input_num2, 1) + self.theta_b0
        self.theta_b = np.array(theta_b0, theta_b1, theta_b2) # åç½®çŸ©é˜µ

    # å®šä¹‰æˆ‘ä»¬çš„è¶…å¯¼LIFç¥žç»å…ƒï¼Œè¾“å‡ºå‘å‡ºè„‰å†²çš„æ•°ç›®ã€‚
    # time_windowä¸ºè„‰å†²å‘å‡ºæ—¶é—´çª—å£ï¼Œè¶…è¿‡æ­¤çª—å£ï¼Œå°†ä¼šæ–­æŽ‰åç½®ç”µæµï¼Œè‡´ä½¿è„‰å†²é¢‘çŽ‡è¿‘ä¹Žä¸º0ã€‚
    # kä¸ºé¢‘çŽ‡å› å­ï¼Œä»¤frequency = k * inputï¼Œä¸ºäº†ç®€åŒ–æ¨¡åž‹ï¼Œæˆ‘ä»¬å‡è®¾è¯¥å› å­æ˜¯å›ºå®šä¸å˜çš„ï¼Œä¸éšç€åç½®æ”¹å˜è€Œæ”¹å˜ã€‚
    # i,j ä»£è¡¨ç¬¬iå±‚ç¬¬jä¸ªç¥žç»å…ƒï¼Œnè¡¨ç¤ºå‰ä¸€å±‚çš„è„‰å†²è¾“å‡ºå‘é‡
    # è®¾ç½®è¶…å¯¼LIFç¥žç»å…ƒå†…çº¦ç‘Ÿå¤«æ£®ç»“ä¸´ç•Œç”µæµä¸º300å¾®å®‰ï¼Œåç½®ä¸º150å¾®å®‰ï¼Œæ¯æ¬¡è„‰å†²è¾“å…¥ç”µæµä¸º50å¾®å®‰ï¼Œå³å¯¹äºŽç¥žç»å…ƒè€Œè¨€ï¼Œä¸€ä¸ªç£é€šé‡å­å¯¹åº”ç”µæµ50å¾®å®‰ï¼Œæ­¤æ—¶a = 6

    def lif_Relu(self, i, j, n):
        # fp = np.sum(n) / self.time_window
        input_all = 0
        # è¾“å…¥å±‚çš„è¾“å…¥æ¥è‡ªADCçš„è¾“å‡ºï¼Œè¿™è¿‡ç¨‹æ²¡æœ‰æƒé‡
        if i == 0:
            input_all = n[j] * self.fai0
        # éšè—å±‚çš„è¾“å…¥æ¥è‡ªè¾“å…¥å±‚çš„è¾“å‡º
        elif i == 1:
            for i in range(self.input_num0):
                input_all += self.w01[i][j] * n[j] * self.fai0
        # è¾“å‡ºå±‚çš„è¾“å…¥æ¥è‡ªéšè—å±‚çš„è¾“å‡º
        elif i == 2:
            for i in range(self.input_num1):
                input_all += self.w12[i][j] * n[j] * self.fai0
        N = (input_all / (self.theta - self.theta_b[i][j]) // 1)
        # å‡è®¾1000å¾®å®‰çš„è¾“å…¥å¯¹åº”å‘å‡ºè„‰å†²é—´éš”ä¸º2.6nsã€‚
        # å®šä¹‰é¢‘çŽ‡å› å­k
        k = 2.6 / 1000  # å•ä½æ˜¯ns/uA
        f = input_all * k
        interval = input_all / k  # å¯¹äºŽä¸åŒè¾“å…¥ï¼Œè¾“å‡ºé—´éš”ä¸åŒã€‚
        s = self.time_window // interval
        if s > N:
            return N, f # Næ·»åŠ åˆ°self.nçŸ©é˜µä¸­ï¼Œfæ·»åŠ åˆ°oçŸ©é˜µä¸­
        else:
            f = s / self.time_window
            return s, f

    # ä½¿ç”¨æ”¹è¿›çš„SFDPå‡†åˆ™,Aä¸ºå¸¸æ•°ï¼Œtåˆ¤æ–­æ˜¯é‚£ä¸€å±‚çš„çªè§¦ï¼Œè‹¥ä¸º0ï¼Œä¸ºè¾“å…¥å±‚ä¸Žéšè—å±‚ä¹‹é—´çš„çªè§¦ï¼Œè‹¥ä¸º1ï¼Œåˆ™ä¸ºéšè—å±‚ä¸Žè¾“å‡ºå±‚ä¹‹é—´çš„çªè§¦ã€‚
    # iã€jè¡¨ç¤ºå‰ä¸€å±‚ç¬¬iä¸ªç¥žç»å…ƒä¸ŽåŽä¸€å±‚ç¬¬jä¸ªç¥žç»å…ƒçš„çªè§¦è¿žæŽ¥ã€‚
    # è‹¥t == 0ï¼Œnå°±æ˜¯è¾“å…¥å±‚çš„è„‰å†²è¾“å‡ºå‘é‡n0ï¼Œå¦åˆ™å°±æ˜¯éšè—å±‚çš„è„‰å†²è¾“å‡ºå‘é‡n1ã€‚

    def sfdp(self, A, t):

        sfdp_w01, sfdp_w12 = np.zeros(self.input_num0, self.input_num1), np.zeros(self.input_num1, self.input_num2)

        # è¾“å…¥å±‚ä¸Žéšè—å±‚ä¹‹é—´çš„çªè§¦
        if t == 0:
            for i in range(self.input_num0):
                for j in range(self.input_num1):
                    f1 = np.sum(np.dot(self.w01[:, j].T, self.o[0]))  #
                    lamda_p = np.sum(self.n[0]) * self.o[0]
                    if self.o[0][i] > self.o[1][j]:
                        sfdp_w01[i, j] = A * math.exp(-lamda_p / f1)
                    elif self.o[0][i] == self.o[1][j]:
                        sfdp_w01[i, j] = 0
                    elif self.o[0][i] < self.o[1][j]:
                        sfdp_w01[i, j] = -A * math.exp(-lamda_p / f1)
            return sfdp_w01

        # éšè—å±‚ä¸Žè¾“å‡ºå±‚ä¹‹é—´çš„çªè§¦
        elif t == 1:
            for i in range(self.input_num1):
                for j in range(self.input_num2):
                    f1 = np.sum(np.dot(self.w12[:, j].T, self.o[1]))  #
                    lamda_p = np.sum(self.n[1]) * self.o[1]
                    if self.o[1][i] > self.o[2][j]:
                        sfdp_w12[i, j] = A * math.exp(-lamda_p / f1)
                    elif self.o[1][i] == self.o[2][j]:
                        sfdp_w12[i, j] = 0
                    elif self.o[1][i] < self.o[2][j]:
                        sfdp_w12[i, j] = -A * math.exp(-lamda_p / f1)
            return sfdp_w12

    # é‡‡ç”¨MSEä½œä¸ºè¯¯å·®å…¬å¼,n0ä¸ºç¬¬ä¸€å±‚çš„è¾“å‡ºè„‰å†²ï¼Œn1ä¸ºç¬¬äºŒå±‚çš„è¾“å‡ºè„‰å†²ï¼Œexä¸ºå„ç¥žç»å…ƒé€šè¿‡æ ‡ç­¾èŽ·å¾—çš„æœŸæœ›ï¼Œo2ä¸ºæœ€åŽä¸€å±‚çš„è¾“å‡ºï¼ŒäºŒè€…å®žè´¨éƒ½æ˜¯è¾“å‡ºçš„è„‰å†²å¯†åº¦
    def backward_w(self, ex):

        delta_w12 = np.zeros(self.input_num1, self.input_num2)
        for i in range(self.input_num1):
            for j in range(self.input_num2):
                delta_w12[i, j] = -(self.n[1][i] * self.fai0 * (ex[j] - self.o[2][j])) / self.x

        delta_w01 = np.zeros(self.input_num0, self.input_num1)
        for i in range(self.input_num0):
            for j in range(self.input_num1):
                for k in range(self.input_num1):
                    delta_w01[i, j] += -(self.n[0][i] * self.fai0 * self.w12[j, k] * (ex[k] - self.o[2][j])) / self.x ** 2
        return delta_w12, delta_w01

    # è®¡ç®—åç½®çš„æ”¹å˜ï¼Œn0ã€n1ã€n2ä¸ºè¾“å‡ºè„‰å†²æ•°ç›®ï¼Œo2ä¸ºè„‰å†²å¯†åº¦ï¼Œexä¸ºå„ç¥žç»å…ƒçš„ç›®æ ‡è¾“å‡º
    def backward_b(self, t, ex):

        delta_theta_b0, delta_theta_b1, delta_theta_b2 = np.zeros(self.input_num0, 1), np.zeros(self.input_num1, 1), np.zeros(self.input_num2, 1)

        if t == 2:
            for i in range(self.input_num2):
                delta_theta_b2[i] = -(ex[i] - self.o[2][i]) * self.n[2][i] / self.x
            return delta_theta_b2

        elif t == 1:
            for i in range(self.input_num1):
                for j in range(self.input_num2):
                    delta_theta_b1[i] += -(self.n[1][i] * self.w12[i, j]) * (ex[j] - self.o[2][j]) / self.x ** 2
            return delta_theta_b1

        elif t == 0:
            for i in range(self.input_num0):
                for k in range(self.input_num2):
                    for j in range(self.input_num1):
                        delta_theta_b0[i] += -(self.w12[j, k] * self.w01[i, j] * self.n[0][i] * (ex[k] - self.o[2][k])) / self.x ** 3
            return delta_theta_b0
